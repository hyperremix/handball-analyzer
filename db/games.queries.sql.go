// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: games.queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getGame = `-- name: GetGame :one
SELECT id, uid, date, league_id, home_team_id, away_team_id, halftime_home_score, halftime_away_score, fulltime_home_score, fulltime_away_score, created_at, updated_at, deleted_at FROM games WHERE id = $1 LIMIT 1
`

func (q *Queries) GetGame(ctx context.Context, id int64) (Game, error) {
	row := q.db.QueryRow(ctx, getGame, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Date,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HalftimeHomeScore,
		&i.HalftimeAwayScore,
		&i.FulltimeHomeScore,
		&i.FulltimeAwayScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listGamesByLeagueUid = `-- name: ListGamesByLeagueUid :many
SELECT games.id, games.uid, games.date, games.league_id, games.home_team_id, games.away_team_id, games.halftime_home_score, games.halftime_away_score, games.fulltime_home_score, games.fulltime_away_score, games.created_at, games.updated_at, games.deleted_at
FROM games
INNER JOIN leagues ON games.league_id = leagues.id
WHERE leagues.uid = $1
ORDER BY games.date DESC
`

func (q *Queries) ListGamesByLeagueUid(ctx context.Context, uid string) ([]Game, error) {
	rows, err := q.db.Query(ctx, listGamesByLeagueUid, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Date,
			&i.LeagueID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HalftimeHomeScore,
			&i.HalftimeAwayScore,
			&i.FulltimeHomeScore,
			&i.FulltimeAwayScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeagueGames = `-- name: ListLeagueGames :many
SELECT id, uid, date, league_id, home_team_id, away_team_id, halftime_home_score, halftime_away_score, fulltime_home_score, fulltime_away_score, created_at, updated_at, deleted_at FROM games WHERE league_id = $1 ORDER BY date DESC
`

func (q *Queries) ListLeagueGames(ctx context.Context, leagueID int64) ([]Game, error) {
	rows, err := q.db.Query(ctx, listLeagueGames, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Date,
			&i.LeagueID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HalftimeHomeScore,
			&i.HalftimeAwayScore,
			&i.FulltimeHomeScore,
			&i.FulltimeAwayScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGameScores = `-- name: UpdateGameScores :exec
UPDATE
    games
SET
    halftime_home_score = $2,
    halftime_away_score = $3,
    fulltime_home_score = $4,
    fulltime_away_score = $5,
    updated_at = NOW()
WHERE
    id = $1
`

type UpdateGameScoresParams struct {
	ID                int64
	HalftimeHomeScore int32
	HalftimeAwayScore int32
	FulltimeHomeScore int32
	FulltimeAwayScore int32
}

func (q *Queries) UpdateGameScores(ctx context.Context, arg UpdateGameScoresParams) error {
	_, err := q.db.Exec(ctx, updateGameScores,
		arg.ID,
		arg.HalftimeHomeScore,
		arg.HalftimeAwayScore,
		arg.FulltimeHomeScore,
		arg.FulltimeAwayScore,
	)
	return err
}

const upsertGame = `-- name: UpsertGame :one
INSERT INTO
    games (uid, league_id, date, home_team_id, away_team_id)
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (uid)
DO
UPDATE
SET
    updated_at = NOW() RETURNING id, uid, date, league_id, home_team_id, away_team_id, halftime_home_score, halftime_away_score, fulltime_home_score, fulltime_away_score, created_at, updated_at, deleted_at
`

type UpsertGameParams struct {
	Uid        string
	LeagueID   int64
	Date       pgtype.Timestamptz
	HomeTeamID int64
	AwayTeamID int64
}

func (q *Queries) UpsertGame(ctx context.Context, arg UpsertGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, upsertGame,
		arg.Uid,
		arg.LeagueID,
		arg.Date,
		arg.HomeTeamID,
		arg.AwayTeamID,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Date,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HalftimeHomeScore,
		&i.HalftimeAwayScore,
		&i.FulltimeHomeScore,
		&i.FulltimeAwayScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
